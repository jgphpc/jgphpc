# {{{ PASSWORD
# 0/ build with: 
#   ./configure --enable-imap
#   --with-ssl=openssl-1.1.1j-ygyfpe7vnnu3fraaa3akij3qmrovnrrg
#   --enable-hcache --enable-smtp --with-gss --with-sasl    # mutt -v
# 1/ create effimap:
#   set imap_pass="..."
#   set smtp_pass="..."
# 2/ gpg --gen-key ;gpg -r jgp@cscs.ch -e effimap
# 3/ read it:
source "gpg -qd $HOME/jgphpc.git/mutt/effimap.gpg |"

# set imap_pass = "..."
# set imap_pass=
# set imap_pass=`grep MUTTPWD ./jgphpc.git/SECRET/SECRET |cut -d " " -f2`
# set smtp_pass=`gpg -qd /Users/lilly/jgphpc.git/mutt/SECRET/effimap.gpg`
# source ~/.mutt/gpg.rc
# }}}
# {{{ ethz
set record = "~/.sent"
# set mailcap_path = ~/.mutt/mailcap.
auto_view text/html
my_hdr From: jgp@cscs.ch (jgp)
# mail.ethz.ch (imap.ethz.ch); Port 993 (SSL)
# mail.ethz.ch (smtp.ethz.ch); 587 (TLS)
set arrow_cursor     = yes
set imap_user        = jeanpi
set spoolfile        = imaps://mail.ethz.ch/INBOX
set folder           = imaps://mail.ethz.ch/
set smtp_url         = "smtp://jeanpi@mail.ethz.ch:587"
set ssl_starttls     = yes
set ssl_force_tls    = yes
set smtp_authenticators = 'gssapi:login'
set mail_check       = 300
set imap_keepalive   = 600
set folder           = "{mail.ethz.ch/ssl}"
set spoolfile        = "{mail.ethz.ch/ssl}inbox"
set record           = "{mail.ethz.ch/ssl}Sent"
set postponed        = "{mail.ethz.ch/ssl}Draft"
# {{{ CACHE
# set header_cache     = ~/.mutt/headercache
# set message_cachedir = ~/.mutt/messagecache
set header_cache     = $HOME/mutt_cache/h
set message_cachedir = $HOME/mutt_cache/m
# set spoolfile=/project/csstaff/piccinal/scripts/mutt/piccinal
# }}}
set from             = 'jgp@cscs.ch'
set realname         = 'Jg Piccinali'
# set hostname         = inf.ethz.ch
mailboxes =Drafts =Sent
unset mbox
# }}}
# {{{ contacts
source $HOME/jgphpc.git/mutt/mutt_contacts
# }}}
# {{{ GMAIL
# set folder = "imaps://imap.gmail.com:993"
# set spoolfile = "+INBOX"
# set smtp_url = "smtps://jgpiccinali@gmail.com@smtp.gmail.com:465/"
# set smtp_pass = "<app password>"
# set imap_user = "jgpiccinali@gmail.com"
# set imap_user = "jgpiccinali"
# }}}

# {{{ Setting
set pager_context=4
set pager_index_lines=10
set pager_stop
# 
bind  pager <backspace> previous-page
bind  pager -           previous-line
bind  pager \eOm        previous-line
bind  pager +           next-line
bind  pager \eOk        next-line
bind  pager \eOM        next-line
bind  pager \e[1~       top
bind  pager \e[4~       bottom
bind  index <backspace> previous-entry
bind  index -           previous-entry
bind  index \eOm        previous-entry
bind  index +           next-entry
bind  index \eOk        next-entry
bind  index \eOM        display-message
bind  index \e[H        first-entry
bind  index \e[F        last-entry
bind  index \e[1~       first-entry
bind  index \e[4~       last-entry
bind  alias   <space>   select-entry
bind  alias   x         exit
bind  attach  x         exit
bind  browser x         exit
# Color
mono  message    bold
color message    white          red
color error      brightyellow   red
color indicator  white          red
color tree       brightmagenta  default
color signature  red            default
color attachment brightyellow   red
color search     brightyellow   red
color tilde      brightmagenta  default
color markers    brightmagenta  default
#color bold       brightblack    default
#color underline  green          default
color quoted     brightblue           default
color quoted1    magenta        default
color quoted2    red            default
color quoted3    green          default
color quoted4    cyan           default
color quoted5    blue           default
color quoted6    magenta        default
color quoted7    red            default
color quoted8    green          default
color quoted9    cyan           default
color hdrdefault brightred      default
color header     brightyellow   default  "^(from):"
color header     brightmagenta  default  "^(To):"
color header     brightblue     default  "^(subject):"
#color header     default        default  "[ \t]+[^:]*$"
color body       brightcyan     default  \
  "((ftp|http|https)://|(file|mailto|news):|www\\.)[-a-z@0-9_.:]*[a-z0-9](/[^][{} \t\n\r\"<>()]*[^][{} \t\n\r\"<>().,:])?"
color body       brightcyan     default  "[-a-z_0-9.+]+@[-a-z_0-9.]+"
color body       red            default  "(^| )\\*[-[:alnum:]*]+\\*[,.?]?[ \n]"
# }}}
# {{{ formatting
# http://www.mutt.org/doc/manual/manual-6.html#index_format
# http://us.generation-nt.com/answer/gentoo-user-mutt-index-format-syntax-help-202863622.html
# Default: "%4C %Z %{%b %d} %-15.15L (%4l) %s"
set index_format="%4C %Z %-80.80s %-15.15L %{%D}"
# Headers to ignore
ignore *
unignore date from to cc subject x-mailer resent-from reply-to
# polling frequency (seconds)
set mail_check=30
# And poll the current mailbox more often (seconds)
set timeout=10
# }}}
# {{{ MACROS
# source ~/.mutt/tickets-all.rc
# source ~/.mutt/sort-threads.rc
# macro index <F2> '<limit>Resolved:<enter>' "filter tickets cscs"
# macro index <F3> '<limit>all<enter>' "filter tickets cscs"
# l = filter by ticket #
# L = no filter (all)
# p = Resolved:
# }}}
# {{{ gpg
# Command formats for gpg.
# 
# This version uses gpg-2comp from 
#   http://muppet.faveve.uni-stuttgart.de/~gero/gpg-2comp.tar.gz
#
# $Id: .muttrc,v 1.1 2006/06/14 12:15:24 root Exp $
#
# %p    The empty string when no passphrase is needed,
#       the string "PGPPASSFD=0" if one is needed.
#
#       This is mostly used in conditional % sequences.
#
# %f    Most PGP commands operate on a single file or a file
#       containing a message.  %f expands to this file's name.
#
# %s    When verifying signatures, there is another temporary file
#       containing the detached signature.  %s expands to this
#       file's name.
#
# %a    In "signing" contexts, this expands to the value of the
#       configuration variable $pgp_sign_as.  You probably need to
#       use this within a conditional % sequence.
#
# %r    In many contexts, mutt passes key IDs to pgp.  %r expands to
#       a list of key IDs.

# Note that we explicitly set the comment armor header since GnuPG, when used
# in some localiaztion environments, generates 8bit data in that header, thereby
# breaking PGP/MIME.

# decode application/pgp
set pgp_decode_command="/usr/bin/gpg   %?p?--passphrase-fd 0? --no-verbose --quiet  --batch  --output - %f"

# verify a pgp/mime signature
set pgp_verify_command="/usr/bin/gpg   --no-verbose --quiet  --batch  --output - --verify %s %f"

# decrypt a pgp/mime attachment
set pgp_decrypt_command="/usr/bin/gpg   --passphrase-fd 0 --no-verbose --quiet  --batch  --output - %f"

# create a pgp/mime signed attachment
# set pgp_sign_command="/usr/bin/gpg-2comp --comment '' --no-verbose --batch  --output - --passphrase-fd 0 --armor --detach-sign --textmode %?a?-u %a? %f"
set pgp_sign_command="/usr/bin/gpg    --no-verbose --batch --quiet   --output - --passphrase-fd 0 --armor --detach-sign --textmode %?a?-u %a? %f"

# create a application/pgp signed (old-style) message
# set pgp_clearsign_command="/usr/bin/gpg-2comp --comment ''  --no-verbose --batch  --output - --passphrase-fd 0 --armor --textmode --clearsign %?a?-u %a? %f"
set pgp_clearsign_command="/usr/bin/gpg   --no-verbose --batch --quiet   --output - --passphrase-fd 0 --armor --textmode --clearsign %?a?-u %a? %f"

# create a pgp/mime encrypted attachment
# set pgp_encrypt_only_command="pgpewrap gpg-2comp  -v --batch  --output - --encrypt --textmode --armor --always-trust -- -r %r -- %f"
set pgp_encrypt_only_command="pgpewrap /usr/bin/gpg    --batch  --quiet  --no-verbose --output - --encrypt --textmode --armor --always-trust -- -r %r -- %f"

# create a pgp/mime encrypted and signed attachment
# set pgp_encrypt_sign_command="pgpewrap gpg-2comp  --passphrase-fd 0 -v --batch  --output - --encrypt --sign %?a?-u %a? --armor --always-trust -- -r %r -- %f"
set pgp_encrypt_sign_command="pgpewrap /usr/bin/gpg  --passphrase-fd 0  --batch --quiet  --no-verbose  --textmode --output - --encrypt --sign %?a?-u %a? --armor --always-trust -- -r %r -- %f"

# import a key into the public key ring
set pgp_import_command="/usr/bin/gpg  --no-verbose --import -v %f"

# export a key from the public key ring
set pgp_export_command="/usr/bin/gpg   --no-verbose --export --armor %r"

# verify a key
set pgp_verify_key_command="/usr/bin/gpg   --verbose --batch  --fingerprint --check-sigs %r"

# read in the public key ring
set pgp_list_pubring_command="/usr/bin/gpg   --no-verbose --batch --quiet   --with-colons --list-keys %r" 

# read in the secret key ring
set pgp_list_secring_command="/usr/bin/gpg   --no-verbose --batch --quiet   --with-colons --list-secret-keys %r" 

# fetch keys
# set pgp_getkeys_command="pkspxycwrap %r"

# pattern for good signature - may need to be adapted to locale!

set pgp_good_sign="^gpg: Good signature from"

# OK, here's a version which uses gnupg's message catalog:
# set pgp_good_sign="`gettext -d gnupg -s 'Good signature from "' | tr -d '"'`"
# }}}
